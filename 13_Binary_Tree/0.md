# üå≥ TREES ‚Äì COMPLETE NOTES (BASIC ‚Üí INTERVIEW LEVEL)

> These notes are written assuming **you know NOTHING initially** and will take you step‚Äëby‚Äëstep to **Google / FAANG interview level**. Read slowly. Re‚Äëread. Practice after every section.

---

## 1Ô∏è‚É£ INTRODUCTION TO TREES

### What is a Tree Data Structure?

A **tree** is a **non-linear hierarchical data structure** consisting of **nodes** connected by **edges**.

* Unlike arrays & linked lists (linear)
* Data is stored in **parent ‚Üí child** relationships

```
        A
       / \
      B   C
     / \   \
    D   E   F
```

* `A` ‚Üí root
* `B, C` ‚Üí children of A
* `D, E, F` ‚Üí leaf nodes

---

## 2Ô∏è‚É£ WHY TREES?

### Problems with Linear Data Structures

| Structure   | Issue                               |
| ----------- | ----------------------------------- |
| Array       | Fixed size, slow insertion/deletion |
| Linked List | Slow searching O(n)                 |
| Hashing     | No ordering                         |

### Why Trees are Better

‚úÖ Faster searching
‚úÖ Maintains hierarchy
‚úÖ Efficient insert/delete
‚úÖ Sorted data possible (BST)

---

## 3Ô∏è‚É£ REAL WORLD USE CASES OF TREES

| Application     | Tree Used          |
| --------------- | ------------------ |
| File System     | N-ary Tree         |
| Databases       | B-Trees / B+ Trees |
| Compiler Syntax | Expression Tree    |
| HTML DOM        | Tree               |
| Autocomplete    | Trie               |
| Networking      | Spanning Tree      |

---

## 4Ô∏è‚É£ TREE TERMINOLOGY (VERY IMPORTANT üî•)

| Term    | Meaning                        |
| ------- | ------------------------------ |
| Node    | Each element in tree           |
| Root    | Topmost node                   |
| Parent  | Node having children           |
| Child   | Node derived from parent       |
| Leaf    | Node with no children          |
| Edge    | Connection between nodes       |
| Height  | Longest path from node to leaf |
| Depth   | Distance from root             |
| Level   | Depth + 1                      |
| Subtree | Tree formed from any node      |

---

## 5Ô∏è‚É£ TYPES OF BINARY TREES

### Binary Tree

Each node has **at most 2 children**

### Types

#### 1. Full Reminder

I will continue with **DEEP explanations, diagrams (ASCII), algorithms, dry runs, code (Java/C++/JS), interview traps, and questions** for:

* Binary Tree Implementation
* Traversals (Inorder / Preorder / Postorder / Level Order)
* Binary Search Trees (BST)
* AVL Trees (Rotations explained)
* Segment Trees (Range Queries)
* Tree Construction from Traversals
* Vertical Order Traversal (Google Question)

üëâ This document is intentionally LONG. Scroll slowly and treat it like a **book**.

---

---

## 6Ô∏è‚É£ BINARY TREE IMPLEMENTATION

### What is a Binary Tree?

A **Binary Tree** is a tree in which **each node can have at most two children**:

* Left child
* Right child

```
        10
       /  \
      5    20
     / \     \
    3   7     30
```

‚ö†Ô∏è Important:

* There is **NO ordering rule** in a normal Binary Tree
* Left can be greater than parent
* Right can be smaller than parent

---

### Node Structure

Every binary tree node contains:

* Data
* Left pointer
* Right pointer

#### C++

```cpp
struct Node {
    int data;
    Node* left;
    Node* right;
    Node(int val) {
        data = val;
        left = right = NULL;
    }
};
```

#### Java

```java
class Node {
    int data;
    Node left, right;
    Node(int val) {
        data = val;
        left = right = null;
    }
}
```

#### JavaScript

```js
class Node {
  constructor(val) {
    this.data = val;
    this.left = null;
    this.right = null;
  }
}
```

---

### Creating a Binary Tree Manually

```
Node root = new Node(1);
root.left = new Node(2);
root.right = new Node(3);
root.left.left = new Node(4);
```

Tree formed:

```
      1
     / \
    2   3
   /
  4
```

---

## 7Ô∏è‚É£ TREE TRAVERSALS (üî• MOST IMPORTANT)

Traversal = visiting **each node exactly once** in a specific order

### Types of Traversals

1. Depth First Search (DFS)

   * Inorder
   * Preorder
   * Postorder
2. Breadth First Search (BFS)

   * Level Order

---

## 8Ô∏è‚É£ INORDER TRAVERSAL (L ‚Üí ROOT ‚Üí R)

### Concept

1. Visit Left subtree
2. Visit Root
3. Visit Right subtree

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

Traversal order:

```
4 ‚Üí 2 ‚Üí 5 ‚Üí 1 ‚Üí 3 ‚Üí 6
```

### Recursive Code

#### Java

```java
void inorder(Node root) {
    if(root == null) return;
    inorder(root.left);
    System.out.print(root.data + " ");
    inorder(root.right);
}
```

### Time & Space Complexity

* Time: O(n)
* Space: O(h) (height of tree)

---

## 9Ô∏è‚É£ PREORDER TRAVERSAL (ROOT ‚Üí L ‚Üí R)

### Concept

1. Visit Root
2. Visit Left
3. Visit Right

Traversal:

```
1 ‚Üí 2 ‚Üí 4 ‚Üí 5 ‚Üí 3 ‚Üí 6
```

#### Java

```java
void preorder(Node root) {
    if(root == null) return;
    System.out.print(root.data + " ");
    preorder(root.left);
    preorder(root.right);
}
```

---

## üîü POSTORDER TRAVERSAL (L ‚Üí R ‚Üí ROOT)

Traversal:

```
4 ‚Üí 5 ‚Üí 2 ‚Üí 6 ‚Üí 3 ‚Üí 1
```

Used in:

* Deleting tree
* Expression evaluation

#### Java

```java
void postorder(Node root) {
    if(root == null) return;
    postorder(root.left);
    postorder(root.right);
    System.out.print(root.data + " ");
}
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ LEVEL ORDER TRAVERSAL (BFS)

### Concept

Traverse **level by level** using a Queue

```
1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
```

#### Java

```java
void levelOrder(Node root) {
    if(root == null) return;
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    while(!q.isEmpty()) {
        Node curr = q.poll();
        System.out.print(curr.data + " ");
        if(curr.left != null) q.add(curr.left);
        if(curr.right != null) q.add(curr.right);
    }
}
```

---

## üî• INTERVIEW NOTES (TRAVERSALS)

| Question              | Answer            |
| --------------------- | ----------------- |
| Inorder of BST gives? | Sorted order      |
| BFS uses which DS?    | Queue             |
| DFS uses which DS?    | Stack / Recursion |

---

## PRACTICE QUESTIONS

### Easy

1. Print inorder traversal
2. Count total nodes
3. Find height of tree

### Medium

4. Diameter of binary tree
5. Check balanced tree

### Hard

6. Boundary traversal
7. Zig-zag traversal

---

---

## 1Ô∏è‚É£2Ô∏è‚É£ BINARY SEARCH TREES (BST) ‚Äì FULL INTERVIEW LEVEL

### What is a Binary Search Tree?

A **Binary Search Tree (BST)** is a **special type of binary tree** where:

‚û°Ô∏è **Left Subtree** contains values **LESS than root**
‚û°Ô∏è **Right Subtree** contains values **GREATER than root**
‚û°Ô∏è This rule applies **recursively to every node**

```
        10
       /  \
      5    20
     / \     \
    2   7     30
```

---

### Why BST?

| Problem       | Binary Tree | BST            |
| ------------- | ----------- | -------------- |
| Searching     | O(n)        | O(log n) (avg) |
| Sorted output | ‚ùå           | ‚úÖ (Inorder)    |
| Efficient ops | ‚ùå           | ‚úÖ              |

BST brings **order** into chaos.

---

## BST PROPERTIES (üî• INTERVIEW GOLD)

1. Inorder traversal of BST gives **sorted order**
2. No duplicate values (usually)
3. Worst case becomes **skewed tree** (like linked list)

---

## INSERTION IN BST

### Logic (Think Recursively)

1. If tree empty ‚Üí new node becomes root
2. If value < root ‚Üí go left
3. If value > root ‚Üí go right

### Example Insert: 8

```
Insert into:

        10
       /  \
      5    20

Result:
        10
       /  \
      5    20
       \
        8
```

### Java Code

```java
Node insert(Node root, int val) {
    if(root == null) return new Node(val);
    if(val < root.data)
        root.left = insert(root.left, val);
    else if(val > root.data)
        root.right = insert(root.right, val);
    return root;
}
```

---

## SEARCH IN BST

### Logic

* Compare with root
* Go left or right

### Java Code

```java
boolean search(Node root, int key) {
    if(root == null) return false;
    if(root.data == key) return true;
    if(key < root.data) return search(root.left, key);
    return search(root.right, key);
}
```

Time Complexity:

* Average: O(log n)
* Worst: O(n)

---

## DELETION IN BST (üî• MOST ASKED)

### 3 CASES

#### Case 1: Leaf Node

‚û°Ô∏è Just delete

#### Case 2: One Child

‚û°Ô∏è Replace node with child

#### Case 3: Two Children (IMPORTANT)

‚û°Ô∏è Replace with **Inorder Successor** (smallest in right subtree)

### Java Code (Core Logic)

```java
Node delete(Node root, int key) {
    if(root == null) return null;
    if(key < root.data)
        root.left = delete(root.left, key);
    else if(key > root.data)
        root.right = delete(root.right, key);
    else {
        if(root.left == null) return root.right;
        if(root.right == null) return root.left;
        Node succ = minValue(root.right);
        root.data = succ.data;
        root.right = delete(root.right, succ.data);
    }
    return root;
}
```

---

## BST vs BINARY TREE (INTERVIEW TRAP)

| Feature        | Binary Tree | BST      |
| -------------- | ----------- | -------- |
| Order          | ‚ùå           | ‚úÖ        |
| Search         | O(n)        | O(log n) |
| Sorted Inorder | ‚ùå           | ‚úÖ        |

---

## COMMON BST INTERVIEW QUESTIONS

1. Validate BST
2. Lowest Common Ancestor (LCA)
3. Kth smallest element
4. Range sum in BST

---

## PRACTICE QUESTIONS

### Easy

1. Insert nodes
2. Search key

### Medium

3. Validate BST
4. LCA in BST

### Hard

5. Recover BST
6. Largest BST in Binary Tree

---

---

## 1Ô∏è‚É£3Ô∏è‚É£ AVL TREES ‚Äì SELF BALANCING BINARY SEARCH TREES

### Introduction

An **AVL Tree** is a **self-balancing Binary Search Tree** where the **height difference** between left and right subtrees of **every node** is **at most 1**.

Why AVL? Because **normal BST can become skewed**, leading to O(n) operations.

---

## PROBLEM WITH NORMAL BST (üî• VERY IMPORTANT)

Consider inserting sorted elements:

```
10 ‚Üí 20 ‚Üí 30 ‚Üí 40 ‚Üí 50
```

BST becomes:

```
10
  \
   20
     \
      30
        \
         40
           \
            50
```

‚ùå Height = n
‚ùå Search = O(n)
‚ùå Acts like Linked List

---

## SELF BALANCING BINARY TREES

A self-balancing tree **automatically adjusts itself** after insertion/deletion to keep height **O(log n)**.

Examples:

* AVL Tree
* Red Black Tree
* B Tree

---

## AVL TREE CORE CONCEPT

### Balance Factor (BF)

```
BF = height(left subtree) - height(right subtree)
```

Allowed values:

```
BF ‚àà { -1, 0, +1 }
```

If BF becomes **-2 or +2** ‚Üí tree is **UNBALANCED**

---

## AVL TREE ROTATIONS (üî• HEART OF AVL)

There are **4 rotation cases**

---

### 1Ô∏è‚É£ LL ROTATION (Left-Left Case)

Occurs when:

* Node becomes unbalanced
* Insertion happens in **left subtree of left child**

Before:

```
    30
   /
  20
 /
10
```

After Right Rotation:

```
    20
   /  \
 10   30
```

---

### 2Ô∏è‚É£ RR ROTATION (Right-Right Case)

Occurs when:

* Insertion in **right subtree of right child**

Before:

```
10
  \
   20
     \
      30
```

After Left Rotation:

```
    20
   /  \
 10   30
```

---

### 3Ô∏è‚É£ LR ROTATION (Left-Right Case)

Occurs when:

* Insertion in **right subtree of left child**

Steps:

1. Left rotation on left child
2. Right rotation on node

Before:

```
    30
   /
  10
    \
     20
```

After:

```
     20
    /  \
  10    30
```

---

### 4Ô∏è‚É£ RL ROTATION (Right-Left Case)

Occurs when:

* Insertion in **left subtree of right child**

Steps:

1. Right rotation on right child
2. Left rotation on node

---

## AVL INSERTION ALGORITHM (HIGH LEVEL)

1. Insert like normal BST
2. Update height
3. Calculate balance factor
4. Apply rotation if needed

---

## AVL INSERTION CODE (CORE IDEA ‚Äì JAVA)

```java
Node insert(Node root, int key) {
    if(root == null) return new Node(key);

    if(key < root.data)
        root.left = insert(root.left, key);
    else if(key > root.data)
        root.right = insert(root.right, key);
    else return root;

    root.height = 1 + Math.max(height(root.left), height(root.right));

    int balance = getBalance(root);

    if(balance > 1 && key < root.left.data)
        return rightRotate(root);

    if(balance < -1 && key > root.right.data)
        return leftRotate(root);

    if(balance > 1 && key > root.left.data) {
        root.left = leftRotate(root.left);
        return rightRotate(root);
    }

    if(balance < -1 && key < root.right.data) {
        root.right = rightRotate(root.right);
        return leftRotate(root);
    }

    return root;
}
```

---

## TIME COMPLEXITY (WHY AVL IS POWERFUL)

| Operation | Time     |
| --------- | -------- |
| Search    | O(log n) |
| Insert    | O(log n) |
| Delete    | O(log n) |

Height is **guaranteed logarithmic**.

---

## AVL vs BST (INTERVIEW CLASSIC)

| Feature   | BST        | AVL      |
| --------- | ---------- | -------- |
| Balanced  | ‚ùå          | ‚úÖ        |
| Search    | O(n) worst | O(log n) |
| Rotations | ‚ùå          | ‚úÖ        |

---

## PRACTICE QUESTIONS (AVL)

### Easy

1. Calculate balance factor
2. Identify rotation type

### Medium

3. Insert nodes & balance tree
4. Height of AVL

### Hard

5. Delete in AVL tree
6. AVL vs Red Black Tree

---

---

## 1Ô∏è‚É£4Ô∏è‚É£ SEGMENT TREES ‚Äì RANGE QUERIES (INTERVIEW FAVORITE üî•)

### About the Lecture

Segment Trees are used to **answer range queries efficiently** on an array where:

* Multiple queries are asked
* Array elements can be updated

Typical queries:

* Range Sum
* Range Minimum
* Range Maximum

---

## WHY USE SEGMENT TREES?

### Problem with Naive Approach

Given array:

```
arr = [1, 3, 5, 7, 9, 11]
```

Query: Sum from index 1 to 4

* Brute force: O(n) per query ‚ùå
* Multiple queries ‚Üí very slow

---

### Why Segment Tree Wins

| Approach     | Query    | Update   |
| ------------ | -------- | -------- |
| Brute Force  | O(n)     | O(1)     |
| Prefix Sum   | O(1)     | O(n)     |
| Segment Tree | O(log n) | O(log n) |

Segment Tree balances **query + update** perfectly.

---

## SEGMENT TREE THEORY

### What is a Segment Tree?

A **Segment Tree** is a **binary tree** where:

* Each node stores information about a segment (range)
* Root stores info of entire array
* Leaves store individual elements

---

### Structure Example

Array:

```
[1, 3, 5, 7]
```

Tree (Sum):

```
           [0-3]=16
          /          \
     [0-1]=4        [2-3]=12
     /     \        /      \
 [0]=1   [1]=3   [2]=5   [3]=7
```

---

## BUILDING SEGMENT TREE

### Steps

1. Start with full range (0 to n-1)
2. Divide range into halves
3. Recursively build left & right
4. Merge results

---

### Java Code ‚Äì Build Tree (Sum)

```java
void build(int idx, int low, int high, int[] arr, int[] seg) {
    if(low == high) {
        seg[idx] = arr[low];
        return;
    }
    int mid = (low + high) / 2;
    build(2*idx+1, low, mid, arr, seg);
    build(2*idx+2, mid+1, high, arr, seg);
    seg[idx] = seg[2*idx+1] + seg[2*idx+2];
}
```

---

## RANGE QUERY IN SEGMENT TREE

### Types of Overlap

1. **No Overlap** ‚Üí return identity (0 for sum)
2. **Complete Overlap** ‚Üí return node value
3. **Partial Overlap** ‚Üí go left + right

---

### Java Code ‚Äì Range Sum Query

```java
int query(int idx, int low, int high, int l, int r, int[] seg) {
    if(r < low || high < l) return 0;
    if(l <= low && high <= r) return seg[idx];
    int mid = (low + high) / 2;
    return query(2*idx+1, low, mid, l, r, seg)
         + query(2*idx+2, mid+1, high, l, r, seg);
}
```

---

## UPDATING ELEMENTS IN SEGMENT TREE

### Point Update

Update a single index and **propagate change upward**

---

### Java Code ‚Äì Update

```java
void update(int idx, int low, int high, int pos, int val, int[] seg) {
    if(low == high) {
        seg[idx] = val;
        return;
    }
    int mid = (low + high) / 2;
    if(pos <= mid)
        update(2*idx+1, low, mid, pos, val, seg);
    else
        update(2*idx+2, mid+1, high, pos, val, seg);
    seg[idx] = seg[2*idx+1] + seg[2*idx+2];
}
```

---

## TIME & SPACE COMPLEXITY

| Operation | Complexity |
| --------- | ---------- |
| Build     | O(n)       |
| Query     | O(log n)   |
| Update    | O(log n)   |
| Space     | O(4n)      |

---

## INTERVIEW PATTERNS (VERY IMPORTANT üî•)

1. Range Sum Query
2. Range Minimum Query (RMQ)
3. XOR range query
4. Lazy propagation (advanced)

---

## PRACTICE QUESTIONS

### Easy

1. Build segment tree
2. Range sum query

### Medium

3. Range min query
4. Point update

### Hard

5. Lazy propagation
6. Segment tree on strings

---

---

## 1Ô∏è‚É£5Ô∏è‚É£ BINARY TREE FROM PREORDER & INORDER TRAVERSAL (ADVANCED üî•)

### Problem Statement

You are given:

* Preorder traversal of a Binary Tree
* Inorder traversal of the same Binary Tree

üëâ Construct the **original binary tree**.

This is a **VERY COMMON INTERVIEW QUESTION** (Amazon, Google, Microsoft).

---

## WHY THIS WORKS (KEY INTUITION)

### Traversal Properties

* **Preorder** ‚Üí `Root | Left | Right`
* **Inorder** ‚Üí `Left | Root | Right`

üí° Key Idea:

* First element of preorder is always the **ROOT**
* Root splits inorder into **left subtree** and **right subtree**

---

## STEP-BY-STEP EXAMPLE

### Gi
