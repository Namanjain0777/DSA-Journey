# Hashing
Technique to store and retrieve data efficiently

Convert data(Key) into a unique index using hash function and stored the values at that index in a hash table

Fastest way to access data ; average O(1)

Hash function convert "One" into indexesin memory 

# Hash Function 
Convert a key(String / Int) into a numerical index

1. Deterministic -> Same Input - Same Hash always

2. uniform Distribution

3. Efficient

4. Minimize Collision

Its use internally by java's HashMap & HashSet

# Hash Table
Key - value pair

where key is always int 

handle collision using chaining or open addressing

# Collision Handling Techniques
## Chaining -> HashMap

its lest sensitive to hash Function

Each index stores a linked list or ArrayList of Entries

1. Easy to implement
2. Average Time = O(1)
3. Worst Case = O(n)

TC -> O(1+ alpha)
alpha = linked list 

## Open Addressing
better Cache performance

if a slot is occupied , find another empty one using a specific rules

techniques

1. Linear Probing -> (hash + i) % Table_Size
2. Quadratic Probing -> (hash + i^2) % Table_Size
3. Double Hashing  ->(hash1 + i*hash2) % Table_Size

Risk of Clustering

Deletion and resizing are tricky

Deletion O(1/1-Alpha)

### Uniform Hashing Assumption

Every key is equally likely to have m! permutation 

cost of next operation <= 1/1-alpha

alpha = n/m

## Hash Function

1. Division Rule Of Hashing
        H(K) = K%M

        k =key

        m = size of hash table

        Choose m as a Prime NO -> reduce collision

        simple and fast hash methods

2. Multiplication Method

        h(K) = [(a.k)%2^W]>>(w-r)

        a = random no

        w = no of bit in k 

        m = 2^r

        a is odd and 2^w-1 <a < 2^w

        a is not to close to 2^w-1 or 2^w

3. Universal Hashing

H(K) = [(AK+B)%P]%M

A & b are random belonging to [0,1,2,...,P-1]

p ->  large Prime No | p is probability

p[h(k1)=h(k2)] = 1/m

## Load Factor(alpha) -> expected key per slot

aplha = no of elements(n) / size of table(m)

when alpha exceeds a threshold (like 0.75 in java), rehashing happens

higher alpha -> higher collision -> slower

keep alpha <0.7 for best performance

## Rehashing
when table is too full , we craete a new larger table and reinsert all , all elements using teh new hash function 

happens automatically in java HashMap

Average Case -> Insert , search , delete -> O(1)
Worst Case -> Insert , search , delete -> O(n)

# Hash Map In Java
        its Array of bucket 
        Each bucket stores a linked list 

        HashMap:
                1. Stores key-value pairs
                2. Average time complexity O(1)
                3. Allows one null key and multiple null values
                4. Not thread-safe
                5. Order is NOT maintained
                6. Uses hashCode() + equals() internally
         
# Hash Set
        Internally use hashmap(Only stores Key)
        Store Unique Elements
        
        HashSet:
                1. Stores UNIQUE elements only
                2. Uses HashMap internally
                3. Average time complexity O(1)
                4. Allows one null value
                5. No indexing, unordered
                6. Not thread-safe

Feature	   |   HashSet	   |     HashMap
Stores	   |  Values only  |	Key–Value
Duplicate  |   ❌ No	 |      ❌ Keys
Null	   |    One	   |  One key, many values
Internal   |   HashMap	   |    Hash table


## HashCode()
give Hash Value(Integer)

## equals()
check equality when hash values are same

it its true -> Hash code must be same

### types of hashing
1. Static Hashing  -> Fixes table size
2. Dynamic Hashing -> Table grows/ shrink dynamically | avoid overflow
3. Perfect Hashing -> No Collision