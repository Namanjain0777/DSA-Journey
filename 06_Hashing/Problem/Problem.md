# Hashing – Complete Question Bank (Questions Only)

---

## Easy / Basic Hashing

1. What is hashing?
2. What is a hash function?
3. Why do we use hashing?
4. What is a hash table?
5. What is a key in hashing?
6. What is a value in hashing?
7. What is collision in hashing?
8. Why collisions occur?
9. What is load factor?
10. What does O(1) average time complexity mean in hashing?

11. What is direct addressing?
12. Difference between array indexing and hashing.
13. What is a good hash function?
14. What is modulo-based hashing?
15. What are the limitations of hashing?

---

## Medium Hashing (Concept + Usage)

16. What are different collision resolution techniques?
17. What is chaining in hashing?
18. What is open addressing?
19. What is linear probing?
20. What is quadratic probing?
21. What is double hashing?
22. Difference between chaining and open addressing.
23. What is rehashing?
24. When does rehashing occur?
25. What is clustering in hashing?

26. Time complexity of search, insert, delete in hash table.
27. Space complexity of hash table.
28. Difference between HashMap and Hashtable (Java).
29. Difference between HashMap and TreeMap.
30. Difference between unordered_map and map (C++).

---

## Hard Hashing (Deep Understanding)

31. Why hash table operations are O(1) on average?
32. Why hash table operations become O(n) in worst case?
33. What is universal hashing?
34. What is perfect hashing?
35. What is dynamic hashing?
36. What is extendible hashing?
37. What is separate chaining with linked list?
38. What happens when load factor exceeds threshold?
39. Why resizing hash table is expensive?
40. How hash function affects performance?

---

## Coding-Oriented Hashing Problems

41. Check if an element exists in an array using hashing.
42. Count frequency of elements in an array.
43. Find the first non-repeating element.
44. Find the first repeating element.
45. Check if two arrays are equal using hashing.
46. Find intersection of two arrays.
47. Find union of two arrays.
48. Check if a subarray with given sum exists.
49. Find longest subarray with sum zero.
50. Find longest consecutive sequence.

---

## Interview Level Hashing

51. Why HashMap does not maintain order?
52. How HashMap handles collisions internally?
53. What happens if multiple keys have same hash code?
54. Why HashMap allows one null key?
55. Why Hashtable does not allow null key or value?
56. What is the default size of HashMap?
57. What is the default load factor of HashMap?
58. How HashMap resizing works?
59. Why TreeMap is slower than HashMap?
60. Why unordered_map is faster than map?

---

## Tricky / Advanced Hashing

61. Can hashing be used for sorting?
62. Can hashing solve all search problems?
63. Hashing vs Binary Search Tree.
64. Hashing vs Trie.
65. When should hashing be avoided?
66. How to design a custom hash function?
67. Hashing for strings – challenges.
68. Hashing for large integers.
69. Hashing for floating point numbers.
70. Rolling hash technique.

---

## Final Boss / Interview Killers

71. Explain internal working of HashMap with diagram.
72. Optimize a problem using hashing.
73. Reduce time complexity using hashing.
74. Identify hashing bottleneck in a solution.
75. Explain collision handling with real-life example.

---
