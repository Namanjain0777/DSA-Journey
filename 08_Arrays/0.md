# ğŸ“˜ Java Arrays â€“ Complete Notes

## ğŸ”¹ What is an Array?
- An array is a **collection of elements of the same data type**
- It stores **multiple values using a single variable name**
- Index-based access (0-based indexing)

---

## ğŸ”¹ Why Arrays?
- Perform operations on **multiple values**
- Avoid creating many individual variables
- Efficient data access using index

---

## ğŸ”¹ Array Declaration & Initialization

### Declaration
```java
int[] arr;
```
```
Initialization
arr = new int[5];
```
```
Declaration + Initialization
int[] arr = new int[5];
int[] arr2 = {1, 2, 3, 4, 5};
```
ğŸ”¹ Where Are Arrays Stored? (IMPORTANT ğŸ”¥)
Stack vs Heap
Reference variable â†’ stored in stack

Array object â†’ stored in heap

Example:

int[] arr = new int[3];

arr â†’ stack (reference)

new int[3] â†’ heap (actual array object)

ğŸ”¹ Key Memory Points
Arrays in Java are objects

Array objects are created in the heap

Heap memory uses dynamic memory allocation

Elements may or may not be contiguous
âœ Depends on JVM implementation

ğŸ”¹ Internal Working of Array (Concept)
```
Stack              Heap
-----              ----
arr  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ [10][20][30]
Stack holds reference arr

Heap holds actual array elements

Each element is accessed using index
```
ğŸ”¹ Default Values in Arrays
```
Data Type	Default Value
int	0
float	0.0
boolean	false
char	'\u0000'
Object	null
```
Example:
```
int[] a = new int[3];   // [0, 0, 0]
String[] s = new String[3]; // [null, null, null]
```
ğŸ”¹ Array Length
arr.length
Returns number of elements

It is a property, not a method

ğŸ”¹ Printing Arrays
âŒ Wrong way:

System.out.println(arr);
âœ… Correct way:
```
Arrays.toString(arr);
ğŸ”¹ Traversing an Array
Using for loop
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
Using enhanced for-each loop
for (int x : arr) {
    System.out.println(x);
}
```
ğŸ”¹ 2D Arrays (IMPORTANT ğŸ”¥)
```
Declaration
int[][] arr;
Initialization
int[][] arr = new int[3][4];  // 3 rows, 4 columns
```
ğŸ”¹ 2D Array Memory Representation
2D array is actually an array of arrays

Each row is a separate array in heap
```
arr â”€â–¶ [row0] â”€â–¶ [ ][ ][ ]
      [row1] â”€â–¶ [ ][ ][ ]
      [row2] â”€â–¶ [ ][ ][ ]
```
ğŸ”¹ Length in 2D Arrays
```
arr.length        // number of rows
arr[i].length     // number of columns in ith row
ğŸ”¹ Printing 2D Arrays
System.out.println(Arrays.deepToString(arr));
```
ğŸ”¹ Important Interview Points ğŸ”¥
Arrays are objects in Java

Stored in heap memory

Reference stored in stack

Fixed size (cannot grow or shrink)

Index-based access â†’ O(1)

Default values exist

# ğŸ“˜ ArrayList in Java â€“ Complete Notes

## ğŸ”¹ What is ArrayList?
- `ArrayList` is a **dynamic, resizable array implementation**
- Part of **Java Collections Framework**
- Internally uses an **array**
- Can grow and shrink dynamically

```java
ArrayList<DataType> list = new ArrayList<>();
ğŸ“Œ Uses wrapper classes (not primitives)
Example:

ArrayList<Integer> list = new ArrayList<>();
```
ğŸ”¹ Key Properties of ArrayList
Dynamic size (resizable)

Maintains insertion order

Allows duplicate values

Allows null values

Random access supported â†’ O(1)

Overrides toString() for readable output
```
ğŸ”¹ Commonly Used Methods
list.add(value);              // add element
list.contains(value);         // check element
list.get(index);              // get element at index
list.set(index, value);       // update element
list.remove(index);           // remove by index
list.size();                  // number of elements
Output example:

[a, b, c, d]
```
ğŸ”¹ Internal Working of ArrayList (VERY IMPORTANT ğŸ”¥)
Initial Capacity
Default initial capacity = 10

Created internally when first element is added

What happens when ArrayList becomes full?
Letâ€™s say:

Capacity = 10

You try to add the 11th element

ğŸ‘‰ Internally:

A new larger array is created

New capacity â‰ˆ 1.5 Ã— old capacity

All old elements are copied

New element is added

ğŸ“Œ This is why ArrayList is not memory efficient
```
ğŸ”¹ Time Complexity (IMPORTANT)
Operation	Time Complexity
add() (average)	O(1)
add() (worst â€“ resize)	O(n)
get(index)	O(1)
set(index)	O(1)
remove(index)	O(n)
contains()	O(n)
ğŸ‘‰ Amortized time complexity of add() = O(1)
```
ğŸ”¹ Why ArrayList is Fast for Add?
Because resizing does not happen every time, only occasionally.
This is called amortized analysis.

ğŸ”¹ Multidimensional ArrayList (IMPORTANT ğŸ”¥)
Java does NOT have true multidimensional ArrayList.
Instead, we use ArrayList of ArrayList.
```
Declaration
ArrayList<ArrayList<Integer>> list = new ArrayList<>();
Creating Rows
for (int i = 0; i < 3; i++) {
    list.add(new ArrayList<>());
}
Adding Elements
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        list.get(i).add(j);
    }
}
Example Structure
[
  [0, 1, 2],
  [0, 1, 2],
  [0, 1, 2]
]
```
```
ğŸ”¹ Array vs ArrayList (INTERVIEW FAVORITE)
Feature	            Array	                ArrayList
Size	            Fixed	                 Dynamic
Memory	          Efficient	          Extra overhead
Data Type	  Primitives + Objects	   Objects only
Performance	         Faster	          Slightly slower
Part of Collection	  âŒ	                  âœ…
```
```
Q: Why remove() is slow in ArrayList?
ğŸ‘‰ Because elements need to be shifted after removal.
```
# ğŸ” Searching Algorithms â€“ Complete Notes

## ğŸ”¹ What is Searching?
Searching is the process of **finding a target element** in a data structure like an array or list.

---

## ğŸ”¹ Types of Searching Algorithms
1. Linear Search
2. Binary Search
3. Order-Agnostic Binary Search

---

## ğŸŸ¢ Linear Search Algorithm

### ğŸ“Œ Definition
Linear Search checks **each element one by one** until the target is found or the array ends.

---

### ğŸ§  Algorithm
1. Start from index `0`
2. Compare each element with target
3. If found â†’ return index
4. If not found till end â†’ return `-1`

---

### ğŸ’» Pseudocode
for i = 0 to n-1
if arr[i] == target
return i
return -1


---

### â± Time Complexity
| Case | Complexity |
|----|-----------|
| Best Case | O(1) |
| Worst Case | O(n) |
| Average Case | O(n) |

---

### âœ… When to Use Linear Search?
- Small datasets
- Unsorted arrays
- Simplicity is required

---

## ğŸ”µ Binary Search Algorithm

### ğŸ“Œ Definition
Binary Search works by **dividing the search space into half**.

âš ï¸ **Array must be sorted**

---

### ğŸ§  Conditions
- Array must be **sorted**
- Works on **random-access** structures (arrays)

---

### ğŸ§  Algorithm
1. Find middle element  
   `mid = (start + end) / 2`
2. If `arr[mid] == target` â†’ found
3. If `target > arr[mid]` â†’ search right
4. If `target < arr[mid]` â†’ search left
5. Repeat until `start > end`

---

### ğŸ“Š Example Dry Run

Array:
[3, 4, 6, 9, 11, 12, 14, 20, 36, 48]


Target = `36`
```
Steps:
mid = (0+9)/2 = 4 â†’ arr[4]=11 < 36 â†’ right
mid = (5+9)/2 = 7 â†’ arr[7]=20 < 36 â†’ right
mid = (8+9)/2 = 8 â†’ arr[8]=36 â†’ FOUND
```

---

### â± Time Complexity
| Case | Complexity |
|----|-----------|
| Best Case | O(1) |
| Worst Case | O(log n) |
| Average Case | O(log n) |

---

### âŒ When Binary Search Fails?
- Array is **not sorted**
- Works poorly on linked lists

---

## ğŸŸ£ Order-Agnostic Binary Search (IMPORTANT ğŸ”¥)

### ğŸ“Œ Definition
Order-Agnostic Binary Search works on arrays that are:
- Sorted in **ascending** OR
- Sorted in **descending** order

---

### ğŸ§  Key Idea
1. First check array order:
   - `arr[start] < arr[end]` â†’ Ascending
   - Else â†’ Descending
2. Apply binary search accordingly

---

### ğŸ“Š Example

Descending Array:
[90, 75, 18, 13, 6, 4, 3, 1]


Target = `75`

---

### ğŸ§  Logic
If descending:
- `target > mid` â†’ move left
- `target < mid` â†’ move right

---

### ğŸ’» Pseudocode
```
isAsc = arr[start] < arr[end]

while start <= end:
mid = (start + end) / 2

if arr[mid] == target:
    return mid

if isAsc:
    if target > arr[mid]:
        start = mid + 1
    else:
        end = mid - 1
else:
    if target > arr[mid]:
        end = mid - 1
    else:
        start = mid + 1
return -1
```

---

## ğŸ”¥ Interview Comparison

| Feature | Linear Search | Binary Search |
|------|---------------|---------------|
| Sorted Required | âŒ | âœ… |
| Time Complexity | O(n) | O(log n) |
| Implementation | Easy | Medium |
| Use Case | Small data | Large data |

---

## ğŸ”¥ Interview One-Liners (MEMORIZE)

- "Linear Search checks elements sequentially."
- "Binary Search works only on sorted arrays."
- "Binary Search reduces search space by half."
- "Order-Agnostic Binary Search works for both ascending and descending arrays."

---

## âš ï¸ Interview Trap Questions

**Q: Can Binary Search work on unsorted array?**  
âŒ No

**Q: Why Binary Search is O(log n)?**  
ğŸ‘‰ Because search space is halved every iteration.

---

## ğŸ“Œ When to Use Which?

- **Linear Search** â†’ small / unsorted array
- **Binary Search** â†’ large sorted array
- **Order-Agnostic BS** â†’ sorted but unknown order

---

# ğŸ” Binary Search Variations & 2D Matrix Search

## ğŸ”¹ Binary Search â€“ Basic Assumptions
- Array must be **sorted**
- Can be **ascending** or **descending**
- Uses two pointers:
  - `start`
  - `end`

---

## ğŸ”¹ Checking Sorting Order (Ascending / Descending)

```java
if (arr[start] < arr[end]) {
    // ascending order
} else {
    // descending order
}
```
ğŸ”¹ Binary Search in 1D Array (Recap)
```
Steps
Find middle element
mid = start + (end - start) / 2

Compare arr[mid] with target

Move start or end accordingly

Repeat until start > end
```
ğŸ”¹ Binary Search in 2D Array (Naive Approach)
```
Matrix Example
18   9   12
36  -4   91
44  33   16
Target = 91
Answer = [1, 2]
```
Approach

Traverse each element

Compare with target
```
Time Complexity
Worst Case: O(nÂ²)
ğŸ“Œ Simple but inefficient for large matrices
```
ğŸ”¹ Searching in Matrix (Row-wise & Column-wise Sorted) ğŸ”¥
```
Special Property
Rows are sorted (left â†’ right)

Columns are sorted (top â†’ bottom)

Matrix Example
10   20   30   40
15   25   35   45
18   29   37   49
33   34   38   50
Target = 37
```
```
ğŸ”¹ Optimal Approach (Staircase Search) ğŸ”¥
Idea
Start from top-right corner.

Why Top-Right?
Left â†’ smaller elements

Down â†’ larger elements
```
Algorithm
```
Start at (row = 0, col = last)

If current == target â†’ found

If current > target â†’ move left

If current < target â†’ move down

Stop when row or column goes out of bounds

Dry Run (Target = 37)
40 > 37 â†’ move left
30 < 37 â†’ move down
35 < 37 â†’ move down
37 == target â†’ FOUND
Time Complexity
O(n + m)
Where:

n = number of rows

m = number of columns

ğŸ“Œ Much faster than O(nÂ²)
```
ğŸ”¹ Pseudocode (Row & Column Sorted Matrix)
```
row = 0
col = lastColumn

while row < rows AND col >= 0:
    if matrix[row][col] == target:
        return [row, col]
    else if matrix[row][col] > target:
        col--
    else:
        row++

return [-1, -1]
```
```
ğŸ”¥ Interview Comparison
Approach	Time Complexity
Linear search in matrix	O(nÂ²)
Staircase search	O(n + m)
```
```
ğŸ”¥ Interview One-Liners (MEMORIZE)
"Binary Search works only on sorted data."

"Order-Agnostic Binary Search handles both orders."

"2D matrix with row & column sorting can be searched in O(n + m)."

"Staircase search starts from top-right corner."

âš ï¸ Interview Trap Questions
Q: Can binary search be applied directly on 2D matrix?
ğŸ‘‰ Only if matrix is treated as a flattened sorted array.

Q: Why not start from top-left corner?
ğŸ‘‰ Because both right and down move to larger values â†’ no elimination.

ğŸ“Œ When to Use Which?
Simple matrix â†’ brute force

Row & column sorted matrix â†’ staircase search

Fully sorted matrix â†’ binary search on flattened array
```
# ğŸ” Searching in Sorted Matrix (Advanced Binary Search)

## ğŸ”¹ Problem Type
Matrix is **fully sorted**:
- Each row is sorted
- First element of a row is greater than last element of previous row  
  OR  
- Matrix is sorted in a way that allows binary-search-like elimination

---

## ğŸ”¹ Case-Based Movement Logic (Staircase Method Recap)

Let current element = `matrix[row][col]`

- If `matrix[row][col] == target`  
  â†’ **Answer found**

- If `matrix[row][col] < target`  
  â†’ Move **down**  
  `row++`

- If `matrix[row][col] > target`  
  â†’ Move **left**  
  `col--`

---

## ğŸ”¹ Time Complexity
O(n + m)

Where:
- `n` = number of rows
- `m` = number of columns

---

## ğŸ”¹ Searching in Fully Sorted Matrix (Binary Search Approach) ğŸ”¥

### Example Matrix
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16


Target = `3`

---

## ğŸ”¹ Optimized Strategy

### Step 1: Binary Search on Rows
- Take **middle column**
- Compare middle column element with target
- Eliminate **upper or lower half of rows**

---

### Step 2: Two Rows Remaining
After row elimination, only **2 rows** remain.

Example:
1 2 | 3 4
5 6 | 7 8


---

### Step 3: Final Search
1. Check middle column in both rows
2. Decide which **sub-matrix** to search
3. Apply **Binary Search** in that part

---

## ğŸ”¹ Final Time Complexity
O(log N + log M)


Where:
- `N` = number of rows
- `M` = number of columns

---

## ğŸ”¥ Key Interview Points

- Uses **binary search concept in 2D**
- Faster than staircase search
- Requires **fully sorted matrix**
- Works by reducing rows first, then columns

---