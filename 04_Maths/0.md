# Maths
## Number System
1. Interger.tobinaryString(n)
2. Interger.toString()
3. Interger.toString(n , 2)

## Divisibility and Module Arithmetics
% - > Gives Reminder
1. (a+b)% m = ((a%m)+(b%m))%m

### Euclidean Algo
gcd(a,b) = gcd(b,a%b)

2. LCM = (a*b)/gcd(a,b)
3. (a*x)%m =1

## Prime Number
Check if No is prime -> Divide No Till Root(n)
2 is largest Even Prime Number

### Prime Factorization
60 = 2^2 * 3 * 5

### Sieve of Eratosthenes
    1. Create a boolean array isPrime[0..N]
    2. Assume all numbers are prime (true)
    3. Mark 0 and 1 as not prime
    4. Start from 2
    Mark all multiples of 2 as non-prime
    Then 3, 5, 7â€¦
    5. Stop when i * i > N

## Logorithmic and Exponents
Log a (b) =c -> a^c = b

log 2(n) -> how many times can be divide by 2 before reading 1

## Arithmetic and Geometric Progression
1. AP = n/2(2a + (n-1)d)
2. GP = [a(r^n -1)] / r-1
3. r = a2/a1
4. Sum of first N = n(n-1)/2

# ğŸ”¢ Bit Manipulation â€“ Complete Basics (DSA + Interview)

Bit manipulation works on **binary (0 & 1)** representation of numbers.  
It is **fast**, **memory efficient**, and commonly used in **DSA, system programming, and interviews**.

---

## ğŸ§  Binary Basics

5 = 101
3 = 011

yaml
Copy code

All operations happen **bit by bit**.

---

## 1ï¸âƒ£ AND (`&`)

### Rule
- `1 & 1 = 1`
- Otherwise `0`

### Truth Table
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1

### Example
5 & 3
101
011
001 â†’ 1


### Uses
(n & 1) == 0
Check i-th bit

(n & (1 << i)) != 0
Masking, permissions

2ï¸âƒ£ OR (|)
Rule
If any bit is 1 â†’ result is 1

Truth Table
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1
Example
5 | 3
101
011
---
111  â†’ 7
Uses
Set i-th bit

n | (1 << i)
Enable flags

3ï¸âƒ£ XOR (^)
Rule
Same bits â†’ 0

Different bits â†’ 1

Truth Table

0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
Example
5 ^ 3
101
011
---
110  â†’ 6
Important Properties
x ^ x = 0
x ^ 0 = x
Uses
Find unique number

Swap without temp

a = a ^ b;
b = a ^ b;
a = a ^ b;
4ï¸âƒ£ NOT (~)
Rule
Flips all bits (0 â†’ 1, 1 â†’ 0)

Example (32-bit int)
~5 = -6
Uses
Bit inversion

Low-level operations

âš  Depends on signed integer representation

5ï¸âƒ£ Left Shift (<<)
Rule
Shift bits left

Fill right with 0

Multiply by 2
Example
5 << 1 = 10
5 << 2 = 20
Uses
Fast multiplication

Power of 2
1 << n   // 2^n

6ï¸âƒ£ Right Shift (>>) â€“ Signed
Rule
Shift bits right

Preserves sign bit

Divide by 2
Example
10 >> 1 = 5
Uses
Fast division

Works with negative numbers

7ï¸âƒ£ Unsigned Right Shift (>>>)
Rule
Shift right

Fill left with 0

Ignores sign

Example
-5 >>> 1  â†’ large positive number
Uses
Low-level bit operations

When sign bit must not propagate


## Combinatorial
1. Factorial
    n * n-1 * n-2 * ..... * 1
2. Permutation (nPr)
    n!/(n-r)!
3. Combination(nCr)
    n!/(r!(n-r)!)

## ğŸ§® Mathematical Functions (Java `Math` Class)
Java provides the `Math` class (`java.lang.Math`) for common mathematical operations.  
All methods are **static**, so no object creation is required.

---

### 1ï¸âƒ£ Math.ceil(x)

- Returns the **smallest integer â‰¥ x**
- Return type: `double`

2ï¸âƒ£ Math.floor(x)

Returns the largest integer â‰¤ x

Math.floor(4.9)   // 4.0
Math.floor(-4.2)  // -5.0

ğŸ“Œ Use case: Rounding down

3ï¸âƒ£ Math.round(x)

Rounds to nearest integer

.5 and above â†’ up

Math.round(4.5f)   // 5
Math.round(4.4f)   // 4


ğŸ“Œ Use case: Normal rounding

4ï¸âƒ£ Math.abs(x)

Returns absolute value

Math.abs(-10)   // 10
Math.abs(5)     // 5


ğŸ“Œ Use case: Distance, difference, modulus logic

5ï¸âƒ£ Math.max(a, b)

Returns maximum of two numbers

Math.max(10, 20)  // 20

6ï¸âƒ£ Math.min(a, b)

Returns minimum of two numbers

Math.min(10, 20)  // 10

7ï¸âƒ£ Math.pow(a, b)

Returns a raised to power b

Math.pow(2, 3)  // 8.0


ğŸ“Œ Use case: Exponential calculations

8ï¸âƒ£ Math.sqrt(x)

Returns square root

Math.sqrt(16)  // 4.0


ğŸ“Œ Use case: Geometry, distance formula

9ï¸âƒ£ Math.cbrt(x)

Returns cube root

Math.cbrt(27)  // 3.0

ğŸ”Ÿ Math.random()

Returns random value in range [0.0, 1.0)

Math.random()


Generate random number in range:

int random = (int)(Math.random() * 10); // 0 to 9

1ï¸âƒ£1ï¸âƒ£ Math.log(x)

Natural logarithm (base e)

Math.log(10)

1ï¸âƒ£2ï¸âƒ£ Math.log10(x)

Logarithm base 10

Math.log10(100)  // 2.0

1ï¸âƒ£3ï¸âƒ£ Math.exp(x)

Returns e^x

Math.exp(1)  // 2.718...

1ï¸âƒ£4ï¸âƒ£ Math.sin(x), Math.cos(x), Math.tan(x)

Trigonometric functions (argument in radians)

Math.sin(Math.PI / 2)  // 1.0


# Tips
1. Count No od Digits
    
    a. Use log10(x)+1 
    
    b. use While Loop   

2. Extracting Digit 

    to get last digit -> digit = n%10
    
    remove last digit -> n = n/10

3. Reverse No 

    rev = (rev * 10)+LastDigit

4. Armstrong No
    sum += pow(digit , count)

5. Divisibility check

    n%k==0

6. Factor of a No

    Loop Till Root n

    if (n%i)==0

7. Prime Check 

    Loop i=2 ->Root(n)

    if (n%i)==0 -> False

8. Swap No using XOR

    a=a^b

    b=a^b

    a=a^b

9. Count Set Bit

    Count 1's in binary ->Integer.bitCount(n)

10. Check Power of 2

    (N&(n-1))==0

11. Perfect No

    Sum of divisor (Exclueing Itseft)=Number

12. Strong No

    Sum of factorial of digit = number

13. Fibonachi

    f(n) = f(n-1) + f(n-2)

14. Power Mod
    
    (a^b%m) -> (res * a) % m

15. Sum of Squares

    n(n+1)(2n+1)/6

16. Sum of Cubes

    (N(n+1)/2)^2

17. Jug Problem 

    r = as'+bt' = l

18. Harmonic Progression For Prime

    n[1/2+1/3+1/5+1/7]

19. Newtonâ€“Raphson Method
The **Newtonâ€“Raphson Method** is an **iterative numerical technique** used to find:
- Roots of equations
- Square roots efficiently

It converges **very fast** compared to linear methods.

---

## ğŸ”¹ Formula (Square Root of n)

To find âˆšn:

xâ‚™â‚Šâ‚ = (xâ‚™ + n / xâ‚™) / 2

yaml
Copy code

Where:
- `n` â†’ number whose square root is required
- `xâ‚™` â†’ current approximation
- `xâ‚™â‚Šâ‚` â†’ next approximation

---

## ğŸ”¹ How It Works (Intuition)

- Start with a **guess**
- Improve the guess step by step
- Each iteration gets **closer to the actual root**

---

## ğŸ”¹ Example: âˆš10

Initial guess:
xâ‚€ = 10

makefile
Copy code

Iterations:
xâ‚ = (10 + 10/10) / 2 = 5.5
xâ‚‚ = (5.5 + 10/5.5) / 2 â‰ˆ 3.66
xâ‚ƒ = (3.66 + 10/3.66) / 2 â‰ˆ 3.196

csharp
Copy code

Actual âˆš10 â‰ˆ **3.162**

âœ” Converges very fast

---

## ğŸ”¹ Java Code (Square Root)

```java
public static double sqrt(int n) {
    double x = n;
    double root;

    while (true) {
        root = 0.5 * (x + n / x);

        if (Math.abs(root - x) < 0.0001) {
            break;
        }
        x = root;
    }
    return root;
}