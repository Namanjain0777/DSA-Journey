# Step 1: Learn the Basics

## Lec 1: Things to Know in C++ / Java / Python
(Basics, loops, conditionals, I/O, arrays)
```
1. Count the number of digits in a number
2. Reverse a number
3. Check if a number is a palindrome
4. Find the largest of three numbers
5. Print all numbers from 1 to N that are divisible by 3 or 5
```
ðŸ“Œ Focus: loops, conditions, variables
## Lec 2: Build-up Logical Thinking
(Pattern + thinking approach)
```
1. Print a right-angled triangle star pattern
2. Print a pyramid pattern
3. Print a number pattern like
        1
        12
        123
4. Print an inverted star triangle
5. Print a diamond pattern
```
ðŸ“Œ Focus: nested loops, dry run skill
## Lec 3: STL / Java Collections
(ArrayList, HashSet, HashMap, Stack basics)
```
1. Store N integers in a list and print only unique elements
2. Count frequency of each element in an array
3. Find the first repeating element
4. Sort an array using built-in functions
5. Check if two arrays are equal using collections
```
ðŸ“Œ Focus: using library efficiently
## Lec 4: Basic Maths
(Number theory â€“ very important)
```
1. Check if a number is prime
2. Find GCD of two numbers
3. Find LCM of two numbers
4. Check if a number is an Armstrong number
5. Count trailing zeros in factorial of a number
```
ðŸ“Œ Focus: logic + formulas

## Lec 5: Basic Recursion
(Function calls, base case)
```
1. Print numbers from 1 to N using recursion
2. Print numbers from N to 1 using recursion
3. Find factorial of a number
4. Find sum of digits of a number
5. Reverse a string using recursion
```
ðŸ“Œ Focus: base case + recursive call

## Lec 6: Basic Hashing
(Frequency + fast lookup)
```
1. Count frequency of elements in an array
2. Find the element with maximum frequency
3. Check if two arrays are anagrams
4. Find the first non-repeating character in a string
5. Check if an array contains duplicates
```
ðŸ“Œ Focus: HashMap / HashSet usage

# Step 2: Learn Important Sorting Techniques
## Lec 1: Sorting I
(Bubble, Selection, Insertion)
```
1. Sort an array using Bubble Sort
2. Sort an array using Selection Sort
3. Sort an array using Insertion Sort
4. Check if an array is already sorted (use Bubble Sort optimization)                               ðŸ”´
5. Sort an array in descending order using Insertion Sort                                             ðŸ”´
```
ðŸ“Œ Focus:
Swapping

Passes

Optimization (early break)

## Lec 2: Sorting II  ðŸ”´
(Cycle, Merge, Quick, Count, Radix) 
```
1. Sort an array using Merge Sort
2. Sort an array using Quick Sort
3. Sort an array containing numbers from 1 to N using Cycle Sort
4. Sort an array with values from 0 to 9 using Count Sort
5. Sort large numbers using Radix Sort
```
ðŸ“Œ Focus:

Recursion

Divide & Conquer

Stable vs unstable

Space vs time tradeoff

# STEP 3: ARRAYS
## Lec 1 : Arrays & ArrayList (Basics)
```
1. Find the largest and smallest element in an array
2. Reverse an array in-place
3. Move all zeros to the end of the array
4. Rotate an array by K positions            ðŸ“ŒUse RecusionðŸ“Œ 
5. Find the second largest element in an array
```
ðŸ“Œ Focus: indexing, loops, in-place operations
## Lec 2 : Linear Search
```
1. Search for an element in an array using Linear Search
2. Find the first occurrence of an element
3. Find the last occurrence of an element
4. Count how many times a number appears
5. Check if an element exists in an array
```
ðŸ“Œ Focus: traversal logic
## Lec 3 : Binary Search (Sorted Arrays)
```
1. Implement Binary Search
2. Find the floor of a number in a sorted array
3. Find the ceiling of a number in a sorted array
4. Search an element in a sorted rotated array
5. Find the position to insert an element in sorted array
```
ðŸ“Œ Focus: mid calculation, boundaries

# STEP 4: BINARY SEARCH
## Lec 1 : 1D Binary Search  ðŸ”´
```
1. Implement Binary Search in a sorted array
2. Find the first and last occurrence of an element
3. Find the count of occurrences of an element
4. Find the minimum element in a rotated sorted array
5. Find the peak element in an array
```
ðŸ“Œ Focus: left/right boundaries, mid calculation

## Lec 2 : Binary Search in 2D Arrays  ðŸ”´
```
1. Search an element in a row-wise sorted 2D matrix
2. Search an element in a row-wise & column-wise sorted matrix
3. Search an element in a fully sorted 2D matrix
4. Find the row with maximum number of 1s in a binary matrix
5. Find a peak element in a 2D grid
```
ðŸ“Œ Focus: row elimination, index mapping

## Lec 3 : Binary Search on Answer  ðŸ”´
```
1. Find the integer square root of a number
2. Find the minimum days to make bouquets
3. Find the minimum capacity to ship packages within D days
4. Allocate minimum number of pages to students
5. Find the minimum speed to eat bananas
```
ðŸ“Œ Focus: monotonic condition (true â†’ true)

# STEP 5: STRINGS
## Lec 1 : Strings (Basic)
```
1. Reverse a string
2. Check if a string is a palindrome
3. Count vowels and consonants in a string
4. Find the frequency of each character in a string
5. Remove all spaces from a string
```
ðŸ“Œ Focus: indexing, loops, char handling

## Lec 2 : StringBuilder / StringBuffer
```
1. Reverse a string using StringBuilder
2. Check if two strings are equal using StringBuilder
3. Insert a character at a given index using StringBuilder
4. Delete all vowels from a string using StringBuffer
5. Convert a string to uppercase using StringBuilder
```
ðŸ“Œ Focus: mutability, operations

## Lec 3 : BigInteger & BigDecimal
```
1. Add two very large numbers using BigInteger
2. Multiply two very large numbers using BigInteger
3. Find factorial of a large number using BigInteger
4. Perform division of decimal numbers using BigDecimal
5. Compare two decimal numbers accurately using BigDecimal
```
ðŸ“Œ Focus: precision, overflow handling

# STEP 6: LINKED LIST
## Lec 1 : Singly Linked List
```
1. Insert a node at the beginning of a linked list
2. Insert a node at the end of a linked list
3. Delete a node by value
4. Reverse a singly linked list
5. Find the middle of a linked list        
```
ðŸ“Œ Focus: head handling, traversal

## Lec 2 : Doubly Linked List
```
1. Insert a node at the beginning of a doubly linked list
2. Insert a node at the end of a doubly linked list
3. Delete a node from a doubly linked list
4. Reverse a doubly linked list
5. Traverse a doubly linked list forward and backward
```
ðŸ“Œ Focus: prev + next pointers

## Lec 3 : Circular Linked List
```
1. Insert a node at the beginning of a circular linked list
2. Insert a node at the end of a circular linked list
3. Delete a node from a circular linked list
4. Traverse and print all elements of a circular linked list
5. Check if a linked list is circular or not
```
ðŸ“Œ Focus: last â†’ head connection

## Lec 4 : Hard / Interview-Level Linked List
```
1. Detect a cycle in a linked list
2. Find the starting point of a loop
3. Check if a linked list is a palindrome
4. Merge two sorted linked lists
5. Remove the Nth node from the end of a linked list
```
ðŸ“Œ Focus: slow-fast pointer, edge cases


# STEP 7: RECURSION
## Lec 1 : Recursion â€“ Level 1 (Basics)
```
1. Print numbers from 1 to N using recursion
2. Print numbers from N to 1 using recursion
3. Find factorial of a number
4. Find sum of digits of a number
5. Count number of zeroes in a number
```
## Lec 2 : Recursion â€“ Array Questions
```
1. Check if an array is sorted using recursion
2. Find an element in an array using recursion
3. Find the index of an element using recursion
4. Find all indices of a target element
5. Find the maximum element in an array recursively
```
## Lec 3 : Recursion â€“ Pattern Questions
```
1. Print a right-angled triangle using recursion
2. Print an inverted triangle using recursion
3. Print a square pattern using recursion
4. Print a pyramid pattern using recursion
5. Print a diamond pattern using recursion
```
## Lec 4 : Recursion â€“ Subset / Subsequence / String
```
1. Print all subsequences of a string
2. Return all subsequences of a string in a list
3. Count total number of subsequences
4. Remove all occurrences of a character from a string
5. Skip a particular substring from a string
```
## Lec 5 : Recursion â€“ Permutations
```
1. Print all permutations of a string
2. Return all permutations in a list
3. Count number of permutations of a string
4. Generate permutations with spaces
5. Generate permutations with case change
```

## Lec 6 : Backtracking â€“ Maze Problems
```
1. Count total ways to reach end of a maze
2. Print all paths from start to end
3. Allow diagonal moves and print paths
4. Maze with obstacles
5. Print maze paths using up, down, left, right
```

## Lec 7 : N-Queens / N-Knights / Sudoku
```
1. Solve N-Queens problem
2. Print all valid solutions for N-Queens
3. Solve N-Knights problem
4. Solve Sudoku using backtracking
5. Check if a Sudoku board is valid
```

# STEP 8: BIT MANIPULATION
## Bitwise Operators
```
1. Check if a number is even or odd using bitwise operators
2. Find the ith bit of a number
3. Set the ith bit of a number
4. Clear the ith bit of a number
5. Toggle the ith bit of a number
```
ðŸ“Œ Focus: &, |, ^, <<, >>
## Number Systems
```
1. Convert decimal to binary
2. Convert binary to decimal
3. Convert decimal to octal
4. Convert decimal to hexadecimal
5. Convert binary to hexadecimal
```
ðŸ“Œ Focus: base conversion logic

# STEP 9: STACK & QUEUE
## Lec 1 : Stack
```
1. Implement a stack using array
2. Implement a stack using linked list
3. Reverse a string using a stack
4. Check for balanced parentheses
5. Find the next greater element for each element
```
ðŸ“Œ Focus: LIFO, push/pop/peek
## Lec 2 : Queue
```
1. Implement a queue using array
2. Implement a queue using linked list
3. Implement a circular queue
4. Reverse a queue
5. Generate binary numbers from 1 to N using a queue
```
ðŸ“Œ Focus: FIFO, front/rear handling
## Lec 3 : Stack & Queue
```
1. Implement stack using two queues
2. Implement queue using two stacks
3. Design a Min Stack
4. Find the previous smaller element
5. Evaluate a postfix expression
```
ðŸ“Œ Focus: simulation, auxiliary data structures

# STEP 10: TWO POINTERS & SLIDING WINDOW
## Lec 1 : Two Pointers
```
1. Check if an array has two numbers with given sum
2. Reverse an array using two pointers
3. Remove duplicates from a sorted array
4. Find the pair with minimum difference
5. Check if a string is a palindrome using two pointers
```
ðŸ“Œ Focus: left/right movement
## Lec 2 : Sliding Window
```
1. Find the maximum sum subarray of size K
2. Find the first negative number in every window of size K
3. Find the count of anagrams in a string
4. Find the longest substring without repeating characters
5. Find the minimum size subarray with sum â‰¥ target
```
ðŸ“Œ Focus: expand â†’ shrink window
## Interview-Level (Mixed)
```
1. Two Sum in a sorted array
2. Three Sum problem
3. Container with most water
4. Longest repeating character replacement
5. Subarray with at most K distinct characters
```
ðŸ“Œ Focus: pattern recognition

# STEP 11: HEAPS
## Lec 1 : Heap Basics
```
1. Implement a Min Heap from scratch
2. Implement a Max Heap from scratch
3. Insert an element into a heap
4. Delete the root element from a heap
5. Convert an array into a heap (heapify)
```
ðŸ“Œ Focus: parentâ€“child index formula
## Lec 2 : Priority Queue
```
1. Find the Kth largest element in an array
2. Find the K smallest elements in an array
3. Sort an array using Priority Queue
4. Merge K sorted arrays
5. Find the top K frequent elements 
```
ðŸ“Œ Focus: min-heap vs max-heap choice
## Lec 3 : Heapsort
```
1. Sort an array using Heapsort
2. Perform heapify step by step
3. Sort array in descending order using heap
4. Find the largest element using heap
5. Find the smallest element using heap
```
ðŸ“Œ Focus: in-place sorting, O(n log n)

# STEP 12: GREEDY ALGORITHMS
## Lec 1 : Greedy Basics
```
1. Select the maximum number of activities
2. Find the minimum number of coins for a given amount
3. Check if array elements can form a non-overlapping set of intervals
4. Assign minimum number of platforms to trains
5. Distribute candies to children with minimum total
```
ðŸ“Œ Focus: sorting + local optimal choice
## Lec 2 : Interval & Scheduling Problems
```
1. Merge overlapping intervals
2. Insert a new interval and merge if required
3. Erase minimum number of overlapping intervals
4. Schedule jobs to get maximum profit
5. Find minimum arrows to burst balloons
```
ðŸ“Œ Focus: sorting by end time / start time
## Lec 3 : Huffman Coding (Greedy)
```
1. Build Huffman Tree from given frequencies
2. Generate Huffman codes for characters
3. Calculate total cost of Huffman encoding
4. Encode a string using Huffman coding
5. Decode a Huffman encoded string
```
ðŸ“Œ Focus: priority queue + tree

# STEP 13: BINARY TREES
## Lec 1 : Binary Tree Basics & Traversals
```
1. Implement inorder traversal (recursive)
2. Implement preorder traversal (recursive)
3. Implement postorder traversal (recursive)
4. Implement level order traversal
5. Find the height of a binary tree
```
ðŸ“Œ Focus: recursion + queue
## Lec 2 : Binary Tree Interview Questions
```
1. Count total number of nodes
2. Count leaf nodes in a binary tree
3. Check if two binary trees are identical
4. Find the maximum element in a binary tree
5. Find the diameter of a binary tree
```
ðŸ“Œ Focus: DFS thinking
## Lec 3 : Tree Construction (Preorder + Inorder)
```
1. Construct a binary tree from preorder & inorder
2. Print postorder traversal from given preorder & inorder
3. Verify if given preorder & inorder are valid
4. Construct binary tree and print level order
5. Find the root from preorder & inorder arrays
```
ðŸ“Œ Focus: index mapping
## Lec 4 : Vertical Order / Views
```
1. Print vertical order traversal
2. Print top view of a binary tree
3. Print bottom view of a binary tree
4. Print left view of a binary tree
5. Print right view of a binary tree
```
ðŸ“Œ Focus: BFS + map
## Lec 5 : Tree Conversion
```
1. Convert a binary tree to doubly linked list
2. Convert binary tree to circular doubly linked list
3. Convert binary tree to sum tree
4. Convert binary tree to mirror tree
5. Convert binary tree to flattened linked list
```
ðŸ“Œ Focus: pointer manipulation

# STEP 14: BINARY SEARCH TREES (BST)
## Lec 1 : BST Basics
```
1. Insert a node into a Binary Search Tree
2. Search for a key in a BST
3. Find the minimum value in a BST
4. Find the maximum value in a BST
5. Check if a binary tree is a valid BST
```
ðŸ“Œ Focus: BST property, recursion

## BST Traversal & Properties
```
1. Print inorder traversal of a BST
2. Find the height of a BST
3. Find the floor of a given key in BST
4. Find the ceil of a given key in BST
5. Find the lowest common ancestor (LCA) in a BST
```
ðŸ“Œ Focus: using BST ordering to optimize

## Kth Smallest / Largest in BST 
```
1. Find the Kth smallest element in a BST
2. Find the Kth largest element in a BST
3. Find the rank of a given element in BST
4. Count nodes less than a given value
5. Find the median of a BST
```
ðŸ“Œ Focus: inorder traversal counting

## Correct BST with Two Nodes Swapped
```
1. Detect two swapped nodes in a BST
2. Correct a BST where two nodes are swapped
3. Check if a BST is invalid due to swapping
4. Restore BST without changing structure
5. Correct BST using O(1) extra space
```
ðŸ“Œ Focus: inorder violation, prev pointer

# STEP 15: GRAPHS
## Lec 1 : Graph Basics & Representation
```
1. Represent a graph using adjacency list
2. Represent a graph using adjacency matrix
3. Add an edge in an undirected graph
4. Add an edge in a directed graph
5. Print all vertices and edges of a graph
```
ðŸ“Œ Focus: data structures, indexing

##  Lec 2 : BFS & DFS Traversal 
```
1. Perform BFS traversal of a graph
2. Perform DFS traversal of a graph (recursive)
3. Perform DFS traversal (iterative using stack)
4. Detect a cycle in an undirected graph
5. Count connected components in a graph
```
ðŸ“Œ Focus: visited array, traversal order

##  Lec 3 : Shortest Path (Unweighted Graphs â€“ BFS)
```
1. Find shortest path from source to all nodes (unweighted graph)
2. Find shortest path between two given nodes
3. Find shortest path in a binary matrix
4. Find minimum moves to reach destination in a grid
5. Word Ladder â€“ find length of shortest transformation sequence
```
ðŸ“Œ Focus: BFS + queue + level tracking

##  Lec 4 : Topological Sort & DAG 
```
1. Perform topological sort using DFS
2. Perform topological sort using BFS (Kahnâ€™s Algorithm)
3. Detect a cycle in a directed graph
4. Check if a graph is a DAG
5. Find shortest path in a DAG
```
ðŸ“Œ Focus: indegree, ordering

##  Lec 5 : Graph Interview-Level Problems
```
1. Number of islands in a grid
2. Rotten oranges problem
3. Flood fill algorithm
4. Clone a graph
5. Check if a graph is bipartite
```
ðŸ“Œ Focus: BFS/DFS pattern recognition

# STEP 16: DYNAMIC PROGRAMMING (DP)
## Lec 1 : DP Basics (1D DP)
```
1. Find Nth Fibonacci number using DP
2. Count number of ways to climb stairs
3. Find minimum cost to climb stairs
4. Find maximum sum of non-adjacent elements
5. House Robber problem
```
ðŸ“Œ Focus: recurrence â†’ dp array

## Lec 2 : DP on Arrays 
```
1. Find maximum subarray sum (Kadaneâ€™s DP view)
2. Find longest increasing subsequence (LIS)
3. Find maximum product subarray
4. Find minimum jumps to reach end
5. Find longest bitonic subsequence
```
ðŸ“Œ Focus: state definition

## Lec 3 : DP on Strings 
```
1. Find longest common subsequence (LCS)
2. Find longest common substring
3. Find edit distance between two strings
4. Check if a string is a palindrome using DP
5. Count distinct subsequences
```
ðŸ“Œ Focus: 2D DP tables

##  Lec 4 : DP on Subsequences / Knapsack
```
1. 0/1 Knapsack problem
2. Subset sum problem
3. Count subsets with given sum
4. Partition array into equal sum subsets
5. Minimum difference subset partition
```
ðŸ“Œ Focus: pick / not pick

##  Lec 5 : DP on Grids 
```
1. Count unique paths in a grid
2. Count unique paths with obstacles
3. Find minimum path sum in a grid
4. Find maximum path sum in a grid
5. Find cherry pickup (two paths)
```
ðŸ“Œ Focus: directions + boundaries

## Lec 6 : DP on Trees
```
1. Find maximum path sum in binary tree
2. Find diameter of a binary tree (DP view)
3. House Robber in a binary tree
4. Count number of unique BSTs
5. Find largest independent set in a tree
```
ðŸ“Œ Focus: return multiple values from recursion

# STEP 17: TRIES
## Lec 1 : Trie Basics & Operations 
```
1. Implement a Trie with insert operation
2. Implement search operation in a Trie
3. Implement startsWith(prefix) function
4. Count total words stored in a Trie
5. Delete a word from a Trie
```
ðŸ“Œ Focus: node structure, children map

## Lec 2 : Trie Interview-Level Problems 
```
1. Implement autocomplete system using Trie
2. Find longest common prefix using Trie
3. Count number of words with a given prefix
4. Implement Word Dictionary (add & search with . wildcard)
5. Replace words using Trie (root word problem)
```
ðŸ“Œ Focus: DFS on Trie nodes

# STEP 18: STRINGS (HARD)
## Lec 1 : String Matching (Karpâ€“Rabin) 
```
1. Implement Rabinâ€“Karp algorithm for string matching
2. Find all occurrences of a pattern in a text
3. Count number of times a pattern appears in a text
4. Check if a pattern exists in a text using rolling hash
5. Detect false positives in Rabinâ€“Karp matching
```
ðŸ“Œ Focus: hashing, sliding window

## Lec 2 : Advanced String Problems 
```
1. Find the longest palindromic substring
2. Find the longest repeating substring
3. Find the minimum window substring
4. Check if one string is a rotation of another
5. Group anagrams together
```
ðŸ“Œ Focus: hashing + window + optimization

## Lec 3 : StringBuffer (Advanced Usage) 
```
1. Reverse a string using StringBuffer
2. Remove duplicate characters using StringBuffer
3. Insert a substring at a given index
4. Replace all vowels using StringBuffer
5. Build a large string efficiently using StringBuffer
```
ðŸ“Œ Focus: mutability, thread safety